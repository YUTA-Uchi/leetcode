URL:https://leetcode.com/problems/two-sum/

# Step1

- 使用言語:c言語(近いうちにC++にする予定ですが、一旦比較的慣れているCにしました)
- コードのNote、関数のプロトタイプは問題そのまま。引数名だけ統一のため変更しています(スネークケースへ)
- 所要時間:骨格部分は2~5分(しかしreturn_sizeの使用意図などに悩んで調べたりしたため最終的にはもっと多くかかっている)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int nums_size, int target, int* return_size)
{
	int i;
	int j;
	int *indice_of_sum;

	for (i = 0; i < nums_size; i++)
	{
		for (j = i + 1; j < nums_size; j++)
		{
			if (target - nums[i] == nums[j])
			{
				*return_size = 2;
				indice_of_sum = (int*)malloc(sizeof(int) * (*return_size));
				if (!indice_of_sum)
				{
					*return_size = 0;
					return (NULL);
				}
				indice_of_sum[0] = i;
				indice_of_sum[1] = j;
				return (indice_of_sum);
			}
		}
	}
	*return_size = 0;
	return (NULL);
}
```

## 思考過程
- 問題だけ読んだ時は、愚直な解答(上記解答)はすぐ書けると考えました。
- 問題文から31>log2(10^9)/log2(10)(約29)なのでintで問題なさそうと考えました。31という数字の根拠はintは基本的に32bitであり、先頭1bitは符号に使われるため2^31でOKだろうという判断です。
- ただし、条件判定の際にオーバーフローしないようにしなければならないと考えました。(line23のif文はオーバーフロー対策の意図です)
- Follow-upに書かれているO(n^2)より少ない時間計算量という要件のアルゴリズムは浮かびませんでした。
- その後家に帰宅後実際に実装しようとして、初めてC言語の場合のプロトタイプを確認。引数のreturn_sizeの使用意図がわからず、そこだけ他の方のSolutionsを確認してAcceptedまでもっていきました。
	- コーディング面接などであれば意図を確認してもいいだろうと思います。つまり、どのような呼び出され方を想定しており、return_sizeの使用はどのようにされるか、などです。どのような意図だと想定できるかと聞かれるかもなので、以下のような使用を想定しました。(ただし、自分が呼び出しも含め設計する場合、エラーチェックをしたいので後者のようになり、あまりreturn_sizeに意味が見いだせなくなります。)
	```C
	result = twoSum(nums, nums_size, target, &return_size);
	i = 0;
	while (i < return_size)
		//なんらかの処理
	```
	```C
	result = twoSum(nums, nums_size, target, &return_size);
	if (result)
		i = 0;
		while (i < return_size)
			//なんらかの処理
	else
		//エラー処理
	```
	- 他の方の実装をみると、実際そこに迷っている人もちらほらいました。そして、結局確定的な意図はわからないものの、[mediumの記事](https://medium.com/@AlexanderObregon/solving-the-two-sum-problem-on-leetcode-c-answers-walkthrough-715066492a7a)で正解が見つからなかったときなどに*return_sizeに0を代入している実装を見て、上記のような想定に合致すると感じました(URL先の方はmalloc失敗の場合はエラーハンドリングしていないですが)
- ここまで考えた後、最悪のケースの足し算でも10^9 + 10^9か-10^9 + -10^9なのでオーバーフローの心配はないことに気づきました。そのためline23のif文は元の意図がわかりやすく
```C
if (nums[i] + nums[j] == target)
```
でよいと考えました。

# step2

- ここで様々な方の実装を(c言語に限らず)参照しました。
- https://github.com/t0hsumi/leetcode/pull/11 (辞書:python)
- https://github.com/katataku/leetcode/pull/10 (辞書:python)
- https://github.com/philip82148/leetcode-arai60/pull/1 (hashmap:c++)
- https://github.com/haniwachann/leetcode/pull/2 (map:c++)
	- 平衡二分木、知らなかった(下記に調べた結果を書く)
- https://github.com/tarinaihitori/leetcode/pull/11 (愚直→辞書:python)
- https://github.com/rihib/leetcode/pull/8 (map:go)
	- indexがキーで数字がvalueというよくあるパターンの逆なのでmapの変数名は分かりやすくしとかないとバグを誘いそう
- https://github.com/ryoooooory/LeetCode/pull/18 (HashMap:java)
- https://github.com/ryo-devz/LeetCode/pull/2 (辞書:python)
- https://github.com/hroc135/leetcode/pull/11 (map:go)
- https://github.com/seal-azarashi/leetcode/pull/11 (HashMap:java)
	- 時間計算量と空間計算量 愚直な解答も空間計算量はすぐれている？
- https://github.com/aoshi2025s/leetcode-review/pull/1 (hashmap:c++)
- https://github.com/Yoshiki-Iwasa/Arai60/pull/10 (map:Rust)
	- ここのコメントで引用されていたこの問題を手でやる場合、特に20人で分担している場合の話はなるほどと思った。
	- 現場作業的な話に落とし込むと、作業員みんながタブレットをもっていて、数字を確認するとまず調査済みの中に和がtargetになるものがあるか検索をかける。そして該当なしなら自分が確認した数字とその位置などを記載して調査済みクラウドに入れる。というのがmapと補数を使った解答のイメージですかね。
- https://github.com/kazukiii/leetcode/pull/12 ()
- https://github.com/Ryotaro25/leetcode_first60/pull/12
- https://github.com/erutako/leetcode/pull/2
- https://github.com/TORUS0818/leetcode/pull/13
- https://github.com/fhiyo/leetcode/pull/14
- https://github.com/nittoco/leetcode/commit/9be2925cc5133bd1f9c8c96cccb502a4c567f768#diff-61b61a407d462b1aaeb594ca2a3b7b9ef28eabb0efba555c0bc269412e1ad3acR35
- https://github.com/nittoco/leetcode/blob/nittoco-patch-1/two_sum.md
- https://github.com/kzhra/Grind41/pull/1
- https://github.com/mt4thbewithu/LeetCode/blob/main/1.%20Two%20Sum.py
- https://github.com/goto-untrapped/Arai60/pull/3
- https://github.com/sakupan102/arai60-practice/pull/12
- https://github.com/cheeseNA/leetcode/pull/1
- https://github.com/colorbox/leetcode/pull/3

- indiceがindexの複数形だと勘違いしていました。[MicrosoftStyleGuide](https://learn.microsoft.com/ja-jp/style-guide/a-z-word-list-term-collections/i/index-indexes-indices)によると、通常はindexの複数形はindexes、数学的表現の場合のみindice,indicesを使用することとなっているため今回の件ではindexesが正しいことになります。
- TwoSumという簡潔な関数名から、本流の処理を助けるだけの(かなり使用場所が限られた)ヘルパー関数であるか、もしくは簡潔であるからこそいろんな場面で使用される汎用関数であるかの可能性が高いと直感的には思いました。
	- おそらくほとんどの場合において、O(n^2)の愚直な実装で十分であると思います。懸念なのは時間計算量のみで、分かりやすさ(プログラミング初心者でもわかる)や手を入れる場合も把握がしやすいと思います。
	- どうしても処理時間の速さが求められ、この関数がO(n^2)であることがボトルネックになっている、と分かった段階でようやくさらに早いアルゴリズムに切り替えるのでも遅くないであろうと思います。
	- とはいえ、もし処理速度改善の担当にさせられたときにいくつか思い浮かんだ方がいいと思うので上記の他の方の実装を参考にいくつか実装してみたいと思います。

